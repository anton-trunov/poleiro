(** The [constructor] tactic is one of the most basic forms of
automation available in Coq. What it does is simple: in order to prove
a proposition, the tactic tries to apply each of its constructors in
sequence, until one succeeds. In that case, the proof proceeds with
all the subgoals generated by that constructor, if any. If no
constructor can be applied, the tactic just fails. There is also an
[econstructor] variant, which defers the instantiation of arguments
required by a constructor if it can't infer them immediately. Thus, it
is the analog of [eapply] for [constructor].

The tactics become particularly useful when applied to multiple goals
simultaneously, usually in a sequence of tactics separated by the [;]
operator. Suppose that you can solve each goal in a proof by applying
roughly the same tactic, but need a different constructor for each case:
[[
   beginning_of_proof. (* Generates some subcases.*)

   (* Case 1 *)
   eapply Constructor1.
   rest_of_proof.

   (* Case 2 *)
   eapply Constructor2.
   rest_of_proof.

   ...

]]
By combining the tactics with [;] and using [(e)constructor], Coq can
figure out by itself what needs to be applied for each case, which
results in a more concise proof:
[[
   beginning_of_proof; econstructor; rest_of_proof.
]]

[constructor]'s method for choosing what to apply is clearly not very
sophisticated and does not always work. Sometimes, a proof can proceed
by applying multiple constructors, but only some of them will allow
the proof to be completed. [constructor], on the other hand, will
always choose the first that can be applied, which may or may not be
the one we need.

Fortunately, there is a variant of [constructor] that can be used to
solve this problem. If [t] is a tactic, invoking [constructor t] will
search for a constructor that can be applied to the current goal _and_
allows [t] to be executed in sequence. This nice feature, which is
currently not documented in the Coq user manual, has already been #<a
href="https://sympa.inria.fr/sympa/arc/coq-club/2012-05/msg00097.html">#
discussed#</a># in the Coq mailing list, and was pointed out to me by
David Pichardie.

** An example

Consider the following inductive definition: *)

Section Tree.

Variable A : Type.
Variable comp : A -> A -> comparison.

Inductive tree : Type :=
| Leaf
| Node (t1 : tree) (a : A) (t2 : tree).

Inductive appears (a : A) : tree -> Prop :=
| AHere : forall t1 t2, appears a (Node t1 a t2)
| ALeft : forall t1 a' t2,
            appears a t1 ->
            appears a (Node t1 a' t2)
| ARight : forall t1 a' t2,
             appears a t2 ->
             appears a (Node t1 a' t2).
(*Hint Constructors appears.*)

Fixpoint insert (a : A) (t : tree) : tree :=
  match t with
    | Leaf => Node Leaf a Leaf
    | Node t1 a' t2 =>
      match comp a a' with
        | Lt => Node (insert a t1) a' t2
        | Eq => Node t1 a t2
        | Gt => Node t1 a' (insert a t2)
      end
  end.

Theorem insertAppears : forall a t, appears a (insert a t).
Proof.
  intros a t.
  induction t as [|t1 IH1 a' t2 IH2]; simpl;
  try destruct (comp a a');
  constructor (solve[eauto]).
Qed.

End Tree.
